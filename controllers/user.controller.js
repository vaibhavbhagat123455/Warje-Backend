import jwt from "jsonwebtoken"
import nodemailer from "nodemailer"
import bcrypt from "bcrypt"
import dotenv from "dotenv"
import { supabase } from "../supabase.js"

dotenv.config();

const generateOTP = () => Math.floor(1000 + Math.random() * 9000);

const createToken = (user) => {
	const { user_id, role, email_id } = user;

	return jwt.sign(
		{
			user_id,
			role,
			email_id
		},
		process.env.JWT_SECRET,
		{ expiresIn: "30d" }
	);
};

const transporter = nodemailer.createTransport({
	service: "gmail",
	auth: {
		user: process.env.EMAIL,
		pass: process.env.EMAIL_PASSWORD,
	},
});

// Send OTP
async function sendOTP(req, res) {
	try {
		const { email_id, purpose, name } = req.body;
		if (!email_id || !purpose)
			return res.status(400).json({ message: "Email ID and purpose are required" });

		// ✅ Validate purpose
		if (!["signup", "login"].includes(purpose.toLowerCase()))
			return res.status(400).json({ message: "Invalid purpose. Must be 'signup' or 'login'." });

		if (purpose.toLowerCase() === 'signup' && !name) {
			return res.status(400).json({ message: "Name is required for signup." });
		}

		let userName = null;
		if (name) userName = name;

		const code = generateOTP();
		const expiry_time = new Date(Date.now() + 5 * 60 * 1000).toISOString(); // valid for 5 mins

		// ✅ Store or update in Supabase
		const { data: existingTemp, error: selectError } = await supabase
			.from("temp_users")
			.select("*")
			.eq("email_id", email_id)
			.maybeSingle();

		if (selectError) throw selectError;

		if (existingTemp) {
			const { error: updateError } = await supabase
				.from("temp_users")
				.update({ code, expiry_time, purpose })
				.eq("email_id", email_id);
			if (updateError) throw updateError;
		}

		else {
			const { error: insertError } = await supabase
				.from("temp_users")
				.insert([{ email_id, code, expiry_time, purpose }]);
			if (insertError) throw insertError;
		}

		if (purpose.toLowerCase() === 'login') {

			// THIS IS THE REQUIRED SUPABASE QUERY 
			const { data: user, error: userError } = await supabase
				.from("users")
				.select("name")
				.eq("email_id", email_id)
				.maybeSingle();

			if (!userError && user) {
				userName = user.name;
			}

		}
		//Email subject/message based on purpose
		const subjectText = purpose === "signup"
			? "Your Verification Code for Signup"
			: "Your One-Time Password for Login";

		const mailOptions = {
			from: process.env.EMAIL,
			to: email_id,
			subject: subjectText,

			// The plain text message for email clients that don't render HTML
			text: purpose === "signup"
				? `Your verification OTP for signup is ${code}. It is valid for 5 minutes. DO NOT SHARE THIS CODE.`
				: `Your OTP for login is ${code}. It is valid for 5 minutes. DO NOT SHARE THIS CODE.`,

			html: `
        <div style="font-family: Arial, sans-serif; max-width: 500px; margin: auto; padding: 20px; border-radius: 8px; background-color: #f9f9f9; border: 1px solid #ddd;">
            
            <div style="text-align: center; background-color: #0a1941ff; padding: 15px; border-radius: 8px 8px 0 0;">
                <img src="https://hebbkx1anhila5yf.public.blob.vercel-storage.com/Maharashtra_Police_Insignia_India%5B1%5D-1JIZ4S6NTIdYu8aBpAKvqXl1zXn1VJ.png" alt="Sanket Darshak Logo" style="max-width: 80px;">
                <h2 style="color: #ffffff; margin: 10px 0;">OTP Verification</h2>
            </div>
            
            <div style="background-color: #ffffff; padding: 20px; border-radius: 0 0 8px 8px; text-align: center;">
                <p style="font-size: 16px;">Dear <strong>${userName}</strong>,</p>
                
                <p>Your One-Time Password for 
                <strong>${purpose.toUpperCase()}</strong> is:</p>
                
                <div style="background-color: #f3f4f6; padding: 15px; border-radius: 5px; margin-top: 10px; text-align: center;">
                    <h2 style="color: #030711; font-size: 24px; margin: 0;">${code}</h2>
                    <p style="margin-top: 5px; color: red;">This OTP expires in 5 minutes.</p>
                </div>
            
                <p style="text-align: center; color: gray; font-size: 12px; margin-top: 20px;">
                    If you did not request this OTP, please ignore this email.<br>
                    Thank you, <br>Sanket Darshak Team
                </p>
            </div>
            
            <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
            
            <p style="color:gray; font-size:12px; text-align: center;">This is an autogenerated message. Please do not reply to this email.</p>
        </div>
    `
		};
		await transporter.sendMail(mailOptions);

		res.status(200).json({
			message: `OTP sent successfully to ${email_id} for ${purpose}`,
		});
	} catch (error) {
		console.log("OTP Error:", error);
		res.status(500).json({ message: "Failed to send OTP" });
	}
}

// Verify OTP & Signup
async function signup(req, res) {
	try {
		const { name, email_id, password, rank, code } = req.body;

		if (!name || !rank || !email_id || !password || !code)
			return res.status(400).json({ message: "All fields are required" });

		// Get temp user
		const { data: tempUser, error: tempError } = await supabase
			.from("temp_users")
			.select("*")
			.eq("email_id", email_id)
			.single();

		if (tempError || !tempUser)
			return res.status(400).json({ message: "OTP not found or expired" });

		// Check expiry (if expiry_time column exists)
		const now = new Date();
		const expiry = new Date(tempUser.expiry_time);

		// Adjust the expiry time by adding 5 hours 30 minutes (if your Supabase stores in IST)
		const adjustedExpiry = new Date(expiry.getTime() + (5.5 * 60 * 60 * 1000));

		if (adjustedExpiry.getTime() < now.getTime()) {
			await supabase.from("temp_users").delete().eq("email_id", email_id);
			return res.status(400).json({ message: "OTP expired. Please request again." });
		}


		// Check OTP (simple equality since not hashed)
		if (code.toString() !== tempUser.code.toString())
			return res.status(400).json({ message: "Invalid OTP." });

		// Hash password
		const hashedPassword = await bcrypt.hash(password, 10);

		// Insert user
		const { data: newUser, error: insertError } = await supabase
			.from("users")
			.insert([{ name, rank, email_id, password: hashedPassword }])
			.select()
			.single();

		if (insertError)
			return res.status(500).json({ message: "User creation failed." });

		// Delete temp user
		await supabase.from("temp_users").delete().eq("email_id", email_id);

		res.status(201).json({
			message: "User created successfully",
			// user: newUser,
			user: {
				"name": newUser.name
			}
		});
	} catch (error) {
		console.error("Signup Error:", error);
		res.status(500).json({ message: "Internal server error" });
	}
}

// Login User
async function login(req, res) {
	try {
		const { email_id, password } = req.body;

		// Check required fields
		if (!email_id || !password)
			return res.status(400).json({ message: "Email ID and password are required" });

		// Find user in Supabase
		const { data: user, error } = await supabase
			.from("users")
			.select("*")
			.eq("email_id", email_id)
			.single();

		if (error) {
			return res.status(500).json({ message: "Internal server error" });
		}

		const isMatch = await bcrypt.compare(password, user.password);
		if (!isMatch)
			return res.status(400).json({ message: "Invalid email or password" });

		const token = createToken(user);
		await supabase.from("temp_users").delete().eq("email_id", email_id);

		res.status(200).json({
			message: "Login successful",
			token,
			user: {
				name: user.name,
				rank: user.rank,
				email_id: user.email_id,
			},
		});
	} catch (error) {
		console.error("Login Error:", error);
		res.status(500).json({ message: "Internal server error" });
	}
}

async function editRole(req, res) {
	const { target_email_id, new_role } = req.body;

	try {
		// Update Operation
		const { data: updatedUsers, error } = await supabase
			.from('users')
			.update({
				role: new_role,
				is_verified: true
			})
			.eq('email_id', target_email_id)
			.select('user_id, email_id, role');

		if (error) {
			console.error('Error during role update:', error.message);
			return res.status(500).json({
				success: false,
				message: "Database failed to update the user's role."
			});
		}

		if (!updatedUsers || updatedUsers.length === 0) {
			return res.status(404).json({
				success: false,
				message: `Could not find a user with the email: ${target_email_id}`
			});
		}

		const updatedUser = updatedUsers[0];

		return res.status(200).json({
			success: true,
			message: `Role for user ${updatedUser.email_id} successfully changed to ${updatedUser.role}.`,
			data: {
				email_id: updatedUser.email_id,
				role: updatedUser.role
			}
		});

	} catch (e) {
		console.error('Internal Server Error in editRole:', e.message);
		return res.status(500).json({
			success: false,
			message: "An unexpected error occurred while processing the request."
		});
	}
}


function logoutUser(req, res) {
	res.status(200).json({ message: 'Successfully logged out' });
}


export default {
	sendOTP,
	signup,
	login,
	logoutUser,
	editRole
};
